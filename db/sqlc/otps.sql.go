// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: otps.sql

package db

import (
	"context"
	"time"
)

const createNewOTP = `-- name: CreateNewOTP :one
INSERT INTO otps (
    user_id,
    otp,
    expired,
    expires_at
) VALUES ($1, $2, $3, $4) RETURNING id, user_id, otp, expired, created_at, expires_at, updated_at
`

type CreateNewOTPParams struct {
	UserID    int32     `json:"user_id"`
	Otp       string    `json:"otp"`
	Expired   bool      `json:"expired"`
	ExpiresAt time.Time `json:"expires_at"`
}

func (q *Queries) CreateNewOTP(ctx context.Context, arg CreateNewOTPParams) (Otp, error) {
	row := q.db.QueryRowContext(ctx, createNewOTP,
		arg.UserID,
		arg.Otp,
		arg.Expired,
		arg.ExpiresAt,
	)
	var i Otp
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Otp,
		&i.Expired,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteAllOTPS = `-- name: DeleteAllOTPS :exec
DELETE FROM otps
`

func (q *Queries) DeleteAllOTPS(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteAllOTPS)
	return err
}

const deleteOTP = `-- name: DeleteOTP :exec
DELETE FROM otps WHERE id = $1
`

func (q *Queries) DeleteOTP(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteOTP, id)
	return err
}

const getOTPByID = `-- name: GetOTPByID :one
SELECT id, user_id, otp, expired, created_at, expires_at, updated_at,
       CASE
           WHEN expires_at <= NOW() THEN true
           ELSE expired
       END AS actual_expired
FROM otps
WHERE id = $1
`

type GetOTPByIDRow struct {
	ID            int64       `json:"id"`
	UserID        int32       `json:"user_id"`
	Otp           string      `json:"otp"`
	Expired       bool        `json:"expired"`
	CreatedAt     time.Time   `json:"created_at"`
	ExpiresAt     time.Time   `json:"expires_at"`
	UpdatedAt     time.Time   `json:"updated_at"`
	ActualExpired interface{} `json:"actual_expired"`
}

func (q *Queries) GetOTPByID(ctx context.Context, id int64) (GetOTPByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getOTPByID, id)
	var i GetOTPByIDRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Otp,
		&i.Expired,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.UpdatedAt,
		&i.ActualExpired,
	)
	return i, err
}

const getOTPByUserID = `-- name: GetOTPByUserID :one
SELECT id, user_id, otp, expired, created_at, expires_at, updated_at,
       CASE
           WHEN expires_at <= NOW() THEN true
           ELSE expired
       END AS actual_expired
FROM otps
WHERE user_id = $1
`

type GetOTPByUserIDRow struct {
	ID            int64       `json:"id"`
	UserID        int32       `json:"user_id"`
	Otp           string      `json:"otp"`
	Expired       bool        `json:"expired"`
	CreatedAt     time.Time   `json:"created_at"`
	ExpiresAt     time.Time   `json:"expires_at"`
	UpdatedAt     time.Time   `json:"updated_at"`
	ActualExpired interface{} `json:"actual_expired"`
}

func (q *Queries) GetOTPByUserID(ctx context.Context, userID int32) (GetOTPByUserIDRow, error) {
	row := q.db.QueryRowContext(ctx, getOTPByUserID, userID)
	var i GetOTPByUserIDRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Otp,
		&i.Expired,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.UpdatedAt,
		&i.ActualExpired,
	)
	return i, err
}

const updateOTP = `-- name: UpdateOTP :exec
UPDATE otps
SET 
    otp = $1,
    expired = CASE
                WHEN expires_at <= NOW() THEN true
                ELSE expired  -- Keep the current value of expired if expires_at is in the future
              END,
    updated_at = NOW()
WHERE id = $2
`

type UpdateOTPParams struct {
	Otp string `json:"otp"`
	ID  int64  `json:"id"`
}

func (q *Queries) UpdateOTP(ctx context.Context, arg UpdateOTPParams) error {
	_, err := q.db.ExecContext(ctx, updateOTP, arg.Otp, arg.ID)
	return err
}

const upsertOTP = `-- name: UpsertOTP :one
INSERT INTO otps (
    user_id,
    otp,
    expired,
    expires_at
) VALUES ($1, $2, $3, $4)
ON CONFLICT (user_id) DO UPDATE
SET 
    otp = EXCLUDED.otp,
    expired = EXCLUDED.expired,
    expires_at = EXCLUDED.expires_at
RETURNING id, user_id, otp, expired, created_at, expires_at, updated_at
`

type UpsertOTPParams struct {
	UserID    int32     `json:"user_id"`
	Otp       string    `json:"otp"`
	Expired   bool      `json:"expired"`
	ExpiresAt time.Time `json:"expires_at"`
}

func (q *Queries) UpsertOTP(ctx context.Context, arg UpsertOTPParams) (Otp, error) {
	row := q.db.QueryRowContext(ctx, upsertOTP,
		arg.UserID,
		arg.Otp,
		arg.Expired,
		arg.ExpiresAt,
	)
	var i Otp
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Otp,
		&i.Expired,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.UpdatedAt,
	)
	return i, err
}
