// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: transaction.sql

package db

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const createCryptoMetadata = `-- name: CreateCryptoMetadata :one
INSERT INTO crypto_transaction_metadata (
    destination_wallet,
    transaction_id,
    coin,
    source_hash,
    rate,
    fees,
    received_amount,
    sent_amount,
    service_provider,
    service_transaction_id
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
) RETURNING id, destination_wallet, transaction_id, coin, source_hash, rate, fees, received_amount, sent_amount, service_provider, service_transaction_id
`

type CreateCryptoMetadataParams struct {
	DestinationWallet    uuid.NullUUID  `json:"destination_wallet"`
	TransactionID        uuid.UUID      `json:"transaction_id"`
	Coin                 string         `json:"coin"`
	SourceHash           sql.NullString `json:"source_hash"`
	Rate                 sql.NullString `json:"rate"`
	Fees                 sql.NullString `json:"fees"`
	ReceivedAmount       sql.NullString `json:"received_amount"`
	SentAmount           sql.NullString `json:"sent_amount"`
	ServiceProvider      string         `json:"service_provider"`
	ServiceTransactionID sql.NullString `json:"service_transaction_id"`
}

func (q *Queries) CreateCryptoMetadata(ctx context.Context, arg CreateCryptoMetadataParams) (CryptoTransactionMetadatum, error) {
	row := q.db.QueryRowContext(ctx, createCryptoMetadata,
		arg.DestinationWallet,
		arg.TransactionID,
		arg.Coin,
		arg.SourceHash,
		arg.Rate,
		arg.Fees,
		arg.ReceivedAmount,
		arg.SentAmount,
		arg.ServiceProvider,
		arg.ServiceTransactionID,
	)
	var i CryptoTransactionMetadatum
	err := row.Scan(
		&i.ID,
		&i.DestinationWallet,
		&i.TransactionID,
		&i.Coin,
		&i.SourceHash,
		&i.Rate,
		&i.Fees,
		&i.ReceivedAmount,
		&i.SentAmount,
		&i.ServiceProvider,
		&i.ServiceTransactionID,
	)
	return i, err
}

const createFiatWithdrawalMetadata = `-- name: CreateFiatWithdrawalMetadata :one
INSERT INTO fiat_withdrawal_metadata (
    source_wallet,
    transaction_id,
    rate,
    received_amount,
    sent_amount,
    fees,
    account_name,
    bank_code,
    account_number,
    service_provider,
    service_transaction_id
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
) RETURNING id, source_wallet, rate, received_amount, sent_amount, fees, transaction_id, account_name, bank_code, account_number, service_provider, service_transaction_id
`

type CreateFiatWithdrawalMetadataParams struct {
	SourceWallet         uuid.NullUUID  `json:"source_wallet"`
	TransactionID        uuid.UUID      `json:"transaction_id"`
	Rate                 sql.NullString `json:"rate"`
	ReceivedAmount       sql.NullString `json:"received_amount"`
	SentAmount           sql.NullString `json:"sent_amount"`
	Fees                 sql.NullString `json:"fees"`
	AccountName          sql.NullString `json:"account_name"`
	BankCode             sql.NullString `json:"bank_code"`
	AccountNumber        sql.NullString `json:"account_number"`
	ServiceProvider      sql.NullString `json:"service_provider"`
	ServiceTransactionID sql.NullString `json:"service_transaction_id"`
}

func (q *Queries) CreateFiatWithdrawalMetadata(ctx context.Context, arg CreateFiatWithdrawalMetadataParams) (FiatWithdrawalMetadatum, error) {
	row := q.db.QueryRowContext(ctx, createFiatWithdrawalMetadata,
		arg.SourceWallet,
		arg.TransactionID,
		arg.Rate,
		arg.ReceivedAmount,
		arg.SentAmount,
		arg.Fees,
		arg.AccountName,
		arg.BankCode,
		arg.AccountNumber,
		arg.ServiceProvider,
		arg.ServiceTransactionID,
	)
	var i FiatWithdrawalMetadatum
	err := row.Scan(
		&i.ID,
		&i.SourceWallet,
		&i.Rate,
		&i.ReceivedAmount,
		&i.SentAmount,
		&i.Fees,
		&i.TransactionID,
		&i.AccountName,
		&i.BankCode,
		&i.AccountNumber,
		&i.ServiceProvider,
		&i.ServiceTransactionID,
	)
	return i, err
}

const createGiftcardMetadata = `-- name: CreateGiftcardMetadata :one
INSERT INTO giftcard_transaction_metadata (
    source_wallet,
    transaction_id,
    rate,
    received_amount,
    sent_amount,
    fees,
    service_provider,
    service_transaction_id
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
) RETURNING id, source_wallet, transaction_id, rate, received_amount, sent_amount, fees, service_provider, service_transaction_id
`

type CreateGiftcardMetadataParams struct {
	SourceWallet         uuid.NullUUID  `json:"source_wallet"`
	TransactionID        uuid.UUID      `json:"transaction_id"`
	Rate                 sql.NullString `json:"rate"`
	ReceivedAmount       sql.NullString `json:"received_amount"`
	SentAmount           sql.NullString `json:"sent_amount"`
	Fees                 sql.NullString `json:"fees"`
	ServiceProvider      string         `json:"service_provider"`
	ServiceTransactionID sql.NullString `json:"service_transaction_id"`
}

func (q *Queries) CreateGiftcardMetadata(ctx context.Context, arg CreateGiftcardMetadataParams) (GiftcardTransactionMetadatum, error) {
	row := q.db.QueryRowContext(ctx, createGiftcardMetadata,
		arg.SourceWallet,
		arg.TransactionID,
		arg.Rate,
		arg.ReceivedAmount,
		arg.SentAmount,
		arg.Fees,
		arg.ServiceProvider,
		arg.ServiceTransactionID,
	)
	var i GiftcardTransactionMetadatum
	err := row.Scan(
		&i.ID,
		&i.SourceWallet,
		&i.TransactionID,
		&i.Rate,
		&i.ReceivedAmount,
		&i.SentAmount,
		&i.Fees,
		&i.ServiceProvider,
		&i.ServiceTransactionID,
	)
	return i, err
}

const createServiceMetadata = `-- name: CreateServiceMetadata :one
INSERT INTO services_metadata (
    source_wallet,
    transaction_id,
    rate,
    received_amount,
    sent_amount,
    fees,
    service_type,
    service_provider,
    service_id,
    service_transaction_id
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
) RETURNING id, source_wallet, rate, received_amount, sent_amount, fees, transaction_id, service_type, service_provider, service_id, service_status, service_transaction_id
`

type CreateServiceMetadataParams struct {
	SourceWallet         uuid.NullUUID  `json:"source_wallet"`
	TransactionID        uuid.UUID      `json:"transaction_id"`
	Rate                 sql.NullString `json:"rate"`
	ReceivedAmount       sql.NullString `json:"received_amount"`
	SentAmount           sql.NullString `json:"sent_amount"`
	Fees                 sql.NullString `json:"fees"`
	ServiceType          string         `json:"service_type"`
	ServiceProvider      sql.NullString `json:"service_provider"`
	ServiceID            sql.NullString `json:"service_id"`
	ServiceTransactionID sql.NullString `json:"service_transaction_id"`
}

func (q *Queries) CreateServiceMetadata(ctx context.Context, arg CreateServiceMetadataParams) (ServicesMetadatum, error) {
	row := q.db.QueryRowContext(ctx, createServiceMetadata,
		arg.SourceWallet,
		arg.TransactionID,
		arg.Rate,
		arg.ReceivedAmount,
		arg.SentAmount,
		arg.Fees,
		arg.ServiceType,
		arg.ServiceProvider,
		arg.ServiceID,
		arg.ServiceTransactionID,
	)
	var i ServicesMetadatum
	err := row.Scan(
		&i.ID,
		&i.SourceWallet,
		&i.Rate,
		&i.ReceivedAmount,
		&i.SentAmount,
		&i.Fees,
		&i.TransactionID,
		&i.ServiceType,
		&i.ServiceProvider,
		&i.ServiceID,
		&i.ServiceStatus,
		&i.ServiceTransactionID,
	)
	return i, err
}

const createSwapTransferMetadata = `-- name: CreateSwapTransferMetadata :one
INSERT INTO swap_transfer_metadata (
    currency,
    transaction_id,
    transfer_type,
    description,
    source_wallet,
    destination_wallet,
    user_tag,
    rate,
    fees,
    received_amount,
    sent_amount
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
) RETURNING id, currency, transaction_id, transfer_type, description, source_wallet, destination_wallet, user_tag, rate, fees, received_amount, sent_amount
`

type CreateSwapTransferMetadataParams struct {
	Currency          string         `json:"currency"`
	TransactionID     uuid.UUID      `json:"transaction_id"`
	TransferType      string         `json:"transfer_type"`
	Description       sql.NullString `json:"description"`
	SourceWallet      uuid.NullUUID  `json:"source_wallet"`
	DestinationWallet uuid.NullUUID  `json:"destination_wallet"`
	UserTag           sql.NullString `json:"user_tag"`
	Rate              sql.NullString `json:"rate"`
	Fees              sql.NullString `json:"fees"`
	ReceivedAmount    sql.NullString `json:"received_amount"`
	SentAmount        sql.NullString `json:"sent_amount"`
}

func (q *Queries) CreateSwapTransferMetadata(ctx context.Context, arg CreateSwapTransferMetadataParams) (SwapTransferMetadatum, error) {
	row := q.db.QueryRowContext(ctx, createSwapTransferMetadata,
		arg.Currency,
		arg.TransactionID,
		arg.TransferType,
		arg.Description,
		arg.SourceWallet,
		arg.DestinationWallet,
		arg.UserTag,
		arg.Rate,
		arg.Fees,
		arg.ReceivedAmount,
		arg.SentAmount,
	)
	var i SwapTransferMetadatum
	err := row.Scan(
		&i.ID,
		&i.Currency,
		&i.TransactionID,
		&i.TransferType,
		&i.Description,
		&i.SourceWallet,
		&i.DestinationWallet,
		&i.UserTag,
		&i.Rate,
		&i.Fees,
		&i.ReceivedAmount,
		&i.SentAmount,
	)
	return i, err
}

const createTransaction = `-- name: CreateTransaction :one
INSERT INTO transactions (
    type,
    description,
    transaction_flow,
    status
) VALUES (
    $1, $2, $3, $4
) RETURNING id, type, description, transaction_flow, status, created_at, updated_at, deleted_from_account_id, deleted_to_account_id
`

type CreateTransactionParams struct {
	Type            string         `json:"type"`
	Description     sql.NullString `json:"description"`
	TransactionFlow sql.NullString `json:"transaction_flow"`
	Status          string         `json:"status"`
}

func (q *Queries) CreateTransaction(ctx context.Context, arg CreateTransactionParams) (Transaction, error) {
	row := q.db.QueryRowContext(ctx, createTransaction,
		arg.Type,
		arg.Description,
		arg.TransactionFlow,
		arg.Status,
	)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Description,
		&i.TransactionFlow,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedFromAccountID,
		&i.DeletedToAccountID,
	)
	return i, err
}

const getPendingTransactions = `-- name: GetPendingTransactions :many
SELECT id, type, description, transaction_flow, status, created_at, updated_at, deleted_from_account_id, deleted_to_account_id FROM transactions
WHERE status = 'pending'
ORDER BY created_at DESC
LIMIT $2 OFFSET $1
`

type GetPendingTransactionsParams struct {
	Offset int32 `json:"_offset"`
	Limit  int32 `json:"_limit"`
}

func (q *Queries) GetPendingTransactions(ctx context.Context, arg GetPendingTransactionsParams) ([]Transaction, error) {
	rows, err := q.db.QueryContext(ctx, getPendingTransactions, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Transaction{}
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Description,
			&i.TransactionFlow,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedFromAccountID,
			&i.DeletedToAccountID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransactionByID = `-- name: GetTransactionByID :one
SELECT 
    t.id, t.type, t.description, t.transaction_flow, t.status, t.created_at, t.updated_at, t.deleted_from_account_id, t.deleted_to_account_id,
    COALESCE(st.source_wallet, ct.destination_wallet, gt.source_wallet, fw.source_wallet, sm.source_wallet) as source_wallet,
    COALESCE(st.destination_wallet, ct.destination_wallet) as destination_wallet,
    COALESCE(st.currency, ct.coin) as currency,
    COALESCE(st.rate, ct.rate, gt.rate, fw.rate, sm.rate) as rate,
    COALESCE(st.fees, ct.fees, gt.fees, fw.fees, sm.fees) as fees,
    COALESCE(st.received_amount, ct.received_amount, gt.received_amount, fw.received_amount, sm.received_amount) as received_amount,
    COALESCE(st.sent_amount, ct.sent_amount, gt.sent_amount, fw.sent_amount, sm.sent_amount) as sent_amount
FROM transactions t
LEFT JOIN swap_transfer_metadata st ON t.id = st.transaction_id
LEFT JOIN crypto_transaction_metadata ct ON t.id = ct.transaction_id
LEFT JOIN giftcard_transaction_metadata gt ON t.id = gt.transaction_id
LEFT JOIN fiat_withdrawal_metadata fw ON t.id = fw.transaction_id
LEFT JOIN services_metadata sm ON t.id = sm.transaction_id
WHERE t.id = $1 LIMIT 1
`

type GetTransactionByIDRow struct {
	ID                   uuid.UUID      `json:"id"`
	Type                 string         `json:"type"`
	Description          sql.NullString `json:"description"`
	TransactionFlow      sql.NullString `json:"transaction_flow"`
	Status               string         `json:"status"`
	CreatedAt            time.Time      `json:"created_at"`
	UpdatedAt            time.Time      `json:"updated_at"`
	DeletedFromAccountID uuid.NullUUID  `json:"deleted_from_account_id"`
	DeletedToAccountID   uuid.NullUUID  `json:"deleted_to_account_id"`
	SourceWallet         uuid.NullUUID  `json:"source_wallet"`
	DestinationWallet    uuid.NullUUID  `json:"destination_wallet"`
	Currency             string         `json:"currency"`
	Rate                 sql.NullString `json:"rate"`
	Fees                 sql.NullString `json:"fees"`
	ReceivedAmount       sql.NullString `json:"received_amount"`
	SentAmount           sql.NullString `json:"sent_amount"`
}

func (q *Queries) GetTransactionByID(ctx context.Context, id uuid.UUID) (GetTransactionByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getTransactionByID, id)
	var i GetTransactionByIDRow
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Description,
		&i.TransactionFlow,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedFromAccountID,
		&i.DeletedToAccountID,
		&i.SourceWallet,
		&i.DestinationWallet,
		&i.Currency,
		&i.Rate,
		&i.Fees,
		&i.ReceivedAmount,
		&i.SentAmount,
	)
	return i, err
}

const getTransactionByIDForUpdate = `-- name: GetTransactionByIDForUpdate :one
SELECT id, type, description, transaction_flow, status, created_at, updated_at, deleted_from_account_id, deleted_to_account_id FROM transactions
WHERE id = $1 LIMIT 1
FOR UPDATE
`

func (q *Queries) GetTransactionByIDForUpdate(ctx context.Context, id uuid.UUID) (Transaction, error) {
	row := q.db.QueryRowContext(ctx, getTransactionByIDForUpdate, id)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Description,
		&i.TransactionFlow,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedFromAccountID,
		&i.DeletedToAccountID,
	)
	return i, err
}

const getTransactionMetadata = `-- name: GetTransactionMetadata :one
SELECT 
    CASE t.type
        WHEN 'swap' THEN jsonb_build_object(
            'type', 'swap_transfer',
            'data', to_jsonb(st.*)
        )
        WHEN 'transfer' THEN jsonb_build_object(
            'type', 'swap_transfer',
            'data', to_jsonb(st.*)
        )
        WHEN 'crypto' THEN jsonb_build_object(
            'type', 'crypto',
            'data', to_jsonb(ct.*)
        )
        WHEN 'giftcard' THEN jsonb_build_object(
            'type', 'giftcard',
            'data', to_jsonb(gt.*)
        )
        WHEN 'withdrawal' THEN jsonb_build_object(
            'type', 'withdrawal',
            'data', to_jsonb(fw.*)
        )
        WHEN 'service' THEN jsonb_build_object(
            'type', 'service',
            'data', to_jsonb(sm.*)
        )
    END as metadata
FROM transactions t
LEFT JOIN swap_transfer_metadata st ON t.id = st.transaction_id
LEFT JOIN crypto_transaction_metadata ct ON t.id = ct.transaction_id
LEFT JOIN giftcard_transaction_metadata gt ON t.id = gt.transaction_id
LEFT JOIN fiat_withdrawal_metadata fw ON t.id = fw.transaction_id
LEFT JOIN services_metadata sm ON t.id = sm.transaction_id
WHERE t.id = $1 LIMIT 1
`

func (q *Queries) GetTransactionMetadata(ctx context.Context, id uuid.UUID) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getTransactionMetadata, id)
	var metadata interface{}
	err := row.Scan(&metadata)
	return metadata, err
}

const getTransactionsByDateRange = `-- name: GetTransactionsByDateRange :many
SELECT 
    t.id, t.type, t.description, t.transaction_flow, t.status, t.created_at, t.updated_at, t.deleted_from_account_id, t.deleted_to_account_id,
    COALESCE(st.currency, ct.coin) as currency,
    COALESCE(st.rate, ct.rate, gt.rate, fw.rate, sm.rate) as rate,
    COALESCE(st.received_amount, ct.received_amount, gt.received_amount, fw.received_amount, sm.received_amount) as received_amount,
    COALESCE(st.sent_amount, ct.sent_amount, gt.sent_amount, fw.sent_amount, sm.sent_amount) as sent_amount
FROM transactions t
LEFT JOIN swap_transfer_metadata st ON t.id = st.transaction_id
LEFT JOIN crypto_transaction_metadata ct ON t.id = ct.transaction_id
LEFT JOIN giftcard_transaction_metadata gt ON t.id = gt.transaction_id
LEFT JOIN fiat_withdrawal_metadata fw ON t.id = fw.transaction_id
LEFT JOIN services_metadata sm ON t.id = sm.transaction_id
WHERE t.created_at BETWEEN $1 AND $2
AND ($3::text IS NULL OR t.type = $3)
ORDER BY t.created_at DESC
LIMIT $5 OFFSET $4
`

type GetTransactionsByDateRangeParams struct {
	StartDate       time.Time `json:"start_date"`
	EndDate         time.Time `json:"end_date"`
	TransactionType string    `json:"transaction_type"`
	Offset          int32     `json:"_offset"`
	Limit           int32     `json:"_limit"`
}

type GetTransactionsByDateRangeRow struct {
	ID                   uuid.UUID      `json:"id"`
	Type                 string         `json:"type"`
	Description          sql.NullString `json:"description"`
	TransactionFlow      sql.NullString `json:"transaction_flow"`
	Status               string         `json:"status"`
	CreatedAt            time.Time      `json:"created_at"`
	UpdatedAt            time.Time      `json:"updated_at"`
	DeletedFromAccountID uuid.NullUUID  `json:"deleted_from_account_id"`
	DeletedToAccountID   uuid.NullUUID  `json:"deleted_to_account_id"`
	Currency             string         `json:"currency"`
	Rate                 sql.NullString `json:"rate"`
	ReceivedAmount       sql.NullString `json:"received_amount"`
	SentAmount           sql.NullString `json:"sent_amount"`
}

func (q *Queries) GetTransactionsByDateRange(ctx context.Context, arg GetTransactionsByDateRangeParams) ([]GetTransactionsByDateRangeRow, error) {
	rows, err := q.db.QueryContext(ctx, getTransactionsByDateRange,
		arg.StartDate,
		arg.EndDate,
		arg.TransactionType,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTransactionsByDateRangeRow{}
	for rows.Next() {
		var i GetTransactionsByDateRangeRow
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Description,
			&i.TransactionFlow,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedFromAccountID,
			&i.DeletedToAccountID,
			&i.Currency,
			&i.Rate,
			&i.ReceivedAmount,
			&i.SentAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransactionsByUserID = `-- name: GetTransactionsByUserID :many
WITH user_wallets AS (
    -- If user_id is provided, get all their wallets
    SELECT id as wallet_id 
    FROM swift_wallets
    WHERE CASE 
        WHEN $4::bigint IS NOT NULL THEN customer_id = $4::bigint
        ELSE id = ANY($5::uuid[])
    END
),
wallet_transactions AS (
    -- Get transactions from swap_transfer_metadata where wallet is source or destination
    SELECT t.id, t.type, t.description, t.transaction_flow, t.status, t.created_at, t.updated_at, t.deleted_from_account_id, t.deleted_to_account_id, 'swap_transfer' as metadata_type, to_jsonb(st.*) as metadata
    FROM transactions t
    JOIN swap_transfer_metadata st ON t.id = st.transaction_id 
    JOIN user_wallets uw ON st.source_wallet = uw.wallet_id OR st.destination_wallet = uw.wallet_id

    UNION ALL

    -- Get transactions from crypto_transaction_metadata where wallet is destination
    SELECT t.id, t.type, t.description, t.transaction_flow, t.status, t.created_at, t.updated_at, t.deleted_from_account_id, t.deleted_to_account_id, 'crypto' as metadata_type, to_jsonb(ct.*) as metadata
    FROM transactions t
    JOIN crypto_transaction_metadata ct ON t.id = ct.transaction_id
    JOIN user_wallets uw ON ct.destination_wallet = uw.wallet_id

    UNION ALL

    -- Get transactions from giftcard_transaction_metadata where wallet is source
    SELECT t.id, t.type, t.description, t.transaction_flow, t.status, t.created_at, t.updated_at, t.deleted_from_account_id, t.deleted_to_account_id, 'giftcard' as metadata_type, to_jsonb(gt.*) as metadata
    FROM transactions t
    JOIN giftcard_transaction_metadata gt ON t.id = gt.transaction_id
    JOIN user_wallets uw ON gt.source_wallet = uw.wallet_id

    UNION ALL

    -- Get transactions from fiat_withdrawal_metadata where wallet is source
    SELECT t.id, t.type, t.description, t.transaction_flow, t.status, t.created_at, t.updated_at, t.deleted_from_account_id, t.deleted_to_account_id, 'withdrawal' as metadata_type, to_jsonb(fw.*) as metadata
    FROM transactions t
    JOIN fiat_withdrawal_metadata fw ON t.id = fw.transaction_id
    JOIN user_wallets uw ON fw.source_wallet = uw.wallet_id

    UNION ALL

    -- Get transactions from services_metadata where wallet is source
    SELECT t.id, t.type, t.description, t.transaction_flow, t.status, t.created_at, t.updated_at, t.deleted_from_account_id, t.deleted_to_account_id, 'service' as metadata_type, to_jsonb(sm.*) as metadata
    FROM transactions t
    JOIN services_metadata sm ON t.id = sm.transaction_id
    JOIN user_wallets uw ON sm.source_wallet = uw.wallet_id
)
SELECT 
    t.id,
    t.type,
    t.description,
    t.transaction_flow,
    t.status,
    t.created_at,
    t.updated_at,
    jsonb_build_object(
        'type', t.metadata_type,
        'data', t.metadata
    ) as metadata
FROM wallet_transactions t
WHERE CASE 
    WHEN $1::timestamptz IS NOT NULL THEN t.created_at < $1::timestamptz
    ELSE true
END
AND CASE
    WHEN $2::uuid IS NOT NULL THEN t.id < $2::uuid
    ELSE true
END
ORDER BY t.created_at DESC, t.id DESC
LIMIT $3
`

type GetTransactionsByUserIDParams struct {
	CreatedAt     sql.NullTime  `json:"created_at"`
	TransactionID uuid.NullUUID `json:"transaction_id"`
	Limit         int32         `json:"_limit"`
	UserID        sql.NullInt64 `json:"user_id"`
	WalletIds     []uuid.UUID   `json:"wallet_ids"`
}

type GetTransactionsByUserIDRow struct {
	ID              uuid.UUID       `json:"id"`
	Type            string          `json:"type"`
	Description     sql.NullString  `json:"description"`
	TransactionFlow sql.NullString  `json:"transaction_flow"`
	Status          string          `json:"status"`
	CreatedAt       time.Time       `json:"created_at"`
	UpdatedAt       time.Time       `json:"updated_at"`
	Metadata        json.RawMessage `json:"metadata"`
}

func (q *Queries) GetTransactionsByUserID(ctx context.Context, arg GetTransactionsByUserIDParams) ([]GetTransactionsByUserIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getTransactionsByUserID,
		arg.CreatedAt,
		arg.TransactionID,
		arg.Limit,
		arg.UserID,
		pq.Array(arg.WalletIds),
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTransactionsByUserIDRow{}
	for rows.Next() {
		var i GetTransactionsByUserIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Description,
			&i.TransactionFlow,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransactionsByWallet = `-- name: GetTransactionsByWallet :many
SELECT 
    t.id, t.type, t.description, t.transaction_flow, t.status, t.created_at, t.updated_at, t.deleted_from_account_id, t.deleted_to_account_id,
    CASE 
        WHEN st.source_wallet = $1 THEN 'source'
        ELSE 'destination'
    END as wallet_role,
    COALESCE(st.currency, ct.coin) as currency,
    COALESCE(st.rate, ct.rate, gt.rate, fw.rate, sm.rate) as rate,
    COALESCE(st.fees, ct.fees, gt.fees, fw.fees, sm.fees) as fees,
    COALESCE(st.received_amount, ct.received_amount, gt.received_amount, fw.received_amount, sm.received_amount) as received_amount,
    COALESCE(st.sent_amount, ct.sent_amount, gt.sent_amount, fw.sent_amount, sm.sent_amount) as sent_amount
FROM transactions t
LEFT JOIN swap_transfer_metadata st ON t.id = st.transaction_id
LEFT JOIN crypto_transaction_metadata ct ON t.id = ct.transaction_id
LEFT JOIN giftcard_transaction_metadata gt ON t.id = gt.transaction_id
LEFT JOIN fiat_withdrawal_metadata fw ON t.id = fw.transaction_id
LEFT JOIN services_metadata sm ON t.id = sm.transaction_id
WHERE st.source_wallet = $1 
   OR st.destination_wallet = $1
   OR ct.destination_wallet = $1
   OR gt.source_wallet = $1
   OR fw.source_wallet = $1
   OR sm.source_wallet = $1
ORDER BY t.created_at DESC
LIMIT $3 OFFSET $2
`

type GetTransactionsByWalletParams struct {
	WalletID uuid.NullUUID `json:"wallet_id"`
	Offset   int32         `json:"_offset"`
	Limit    int32         `json:"_limit"`
}

type GetTransactionsByWalletRow struct {
	ID                   uuid.UUID      `json:"id"`
	Type                 string         `json:"type"`
	Description          sql.NullString `json:"description"`
	TransactionFlow      sql.NullString `json:"transaction_flow"`
	Status               string         `json:"status"`
	CreatedAt            time.Time      `json:"created_at"`
	UpdatedAt            time.Time      `json:"updated_at"`
	DeletedFromAccountID uuid.NullUUID  `json:"deleted_from_account_id"`
	DeletedToAccountID   uuid.NullUUID  `json:"deleted_to_account_id"`
	WalletRole           string         `json:"wallet_role"`
	Currency             string         `json:"currency"`
	Rate                 sql.NullString `json:"rate"`
	Fees                 sql.NullString `json:"fees"`
	ReceivedAmount       sql.NullString `json:"received_amount"`
	SentAmount           sql.NullString `json:"sent_amount"`
}

func (q *Queries) GetTransactionsByWallet(ctx context.Context, arg GetTransactionsByWalletParams) ([]GetTransactionsByWalletRow, error) {
	rows, err := q.db.QueryContext(ctx, getTransactionsByWallet, arg.WalletID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTransactionsByWalletRow{}
	for rows.Next() {
		var i GetTransactionsByWalletRow
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Description,
			&i.TransactionFlow,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedFromAccountID,
			&i.DeletedToAccountID,
			&i.WalletRole,
			&i.Currency,
			&i.Rate,
			&i.Fees,
			&i.ReceivedAmount,
			&i.SentAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBillServiceTransactionID = `-- name: UpdateBillServiceTransactionID :one
UPDATE services_metadata
SET service_transaction_id = $1
WHERE transaction_id = $2
RETURNING id, source_wallet, rate, received_amount, sent_amount, fees, transaction_id, service_type, service_provider, service_id, service_status, service_transaction_id
`

type UpdateBillServiceTransactionIDParams struct {
	ServiceTransactionID sql.NullString `json:"service_transaction_id"`
	TransactionID        uuid.UUID      `json:"transaction_id"`
}

func (q *Queries) UpdateBillServiceTransactionID(ctx context.Context, arg UpdateBillServiceTransactionIDParams) (ServicesMetadatum, error) {
	row := q.db.QueryRowContext(ctx, updateBillServiceTransactionID, arg.ServiceTransactionID, arg.TransactionID)
	var i ServicesMetadatum
	err := row.Scan(
		&i.ID,
		&i.SourceWallet,
		&i.Rate,
		&i.ReceivedAmount,
		&i.SentAmount,
		&i.Fees,
		&i.TransactionID,
		&i.ServiceType,
		&i.ServiceProvider,
		&i.ServiceID,
		&i.ServiceStatus,
		&i.ServiceTransactionID,
	)
	return i, err
}

const updateGiftCardServiceTransactionID = `-- name: UpdateGiftCardServiceTransactionID :one
UPDATE giftcard_transaction_metadata
SET service_transaction_id = $1
WHERE transaction_id = $2
RETURNING id, source_wallet, transaction_id, rate, received_amount, sent_amount, fees, service_provider, service_transaction_id
`

type UpdateGiftCardServiceTransactionIDParams struct {
	ServiceTransactionID sql.NullString `json:"service_transaction_id"`
	TransactionID        uuid.UUID      `json:"transaction_id"`
}

func (q *Queries) UpdateGiftCardServiceTransactionID(ctx context.Context, arg UpdateGiftCardServiceTransactionIDParams) (GiftcardTransactionMetadatum, error) {
	row := q.db.QueryRowContext(ctx, updateGiftCardServiceTransactionID, arg.ServiceTransactionID, arg.TransactionID)
	var i GiftcardTransactionMetadatum
	err := row.Scan(
		&i.ID,
		&i.SourceWallet,
		&i.TransactionID,
		&i.Rate,
		&i.ReceivedAmount,
		&i.SentAmount,
		&i.Fees,
		&i.ServiceProvider,
		&i.ServiceTransactionID,
	)
	return i, err
}

const updateTransactionStatus = `-- name: UpdateTransactionStatus :one
UPDATE transactions 
SET status = $2
WHERE id = $1
RETURNING id, type, description, transaction_flow, status, created_at, updated_at, deleted_from_account_id, deleted_to_account_id
`

type UpdateTransactionStatusParams struct {
	ID     uuid.UUID `json:"id"`
	Status string    `json:"status"`
}

func (q *Queries) UpdateTransactionStatus(ctx context.Context, arg UpdateTransactionStatusParams) (Transaction, error) {
	row := q.db.QueryRowContext(ctx, updateTransactionStatus, arg.ID, arg.Status)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Description,
		&i.TransactionFlow,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedFromAccountID,
		&i.DeletedToAccountID,
	)
	return i, err
}
