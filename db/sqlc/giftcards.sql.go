// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: giftcards.sql

package db

import (
	"context"
	"database/sql"
	"encoding/json"

	"github.com/sqlc-dev/pqtype"
)

const fetchGiftCard = `-- name: FetchGiftCard :one
SELECT 
    gc.product_id, 
    gc.product_name, 
    gc.denomination_type, 
    gc.discount_percentage, 
    gc.max_recipient_denomination, 
    gc.min_recipient_denomination, 
    gc.max_sender_denomination, 
    gc.min_sender_denomination, 
    gc.global, 
    gc.metadata, 
    gc.recipient_currency_code, 
    gc.sender_currency_code, 
    gc.sender_fee, 
    gc.sender_fee_percentage, 
    gc.supports_pre_order, 
    gl.logo_url,
    b.brand_name, 
    c.name AS category_name, 
    co.name AS country_name, 
    co.flag_url
FROM 
    gift_cards gc
LEFT JOIN 
    brands b ON gc.brand_id = b.brand_id
LEFT JOIN 
    categories c ON gc.category_id = c.id
LEFT JOIN 
    countries co ON gc.country_id = co.id
LEFT JOIN 
    gift_card_logo_urls gl ON gc.id = gl.gift_card_id
WHERE 
    gc.product_id = $1
`

type FetchGiftCardRow struct {
	ProductID                int64                 `json:"product_id"`
	ProductName              sql.NullString        `json:"product_name"`
	DenominationType         sql.NullString        `json:"denomination_type"`
	DiscountPercentage       sql.NullFloat64       `json:"discount_percentage"`
	MaxRecipientDenomination sql.NullFloat64       `json:"max_recipient_denomination"`
	MinRecipientDenomination sql.NullFloat64       `json:"min_recipient_denomination"`
	MaxSenderDenomination    sql.NullFloat64       `json:"max_sender_denomination"`
	MinSenderDenomination    sql.NullFloat64       `json:"min_sender_denomination"`
	Global                   sql.NullBool          `json:"global"`
	Metadata                 pqtype.NullRawMessage `json:"metadata"`
	RecipientCurrencyCode    sql.NullString        `json:"recipient_currency_code"`
	SenderCurrencyCode       sql.NullString        `json:"sender_currency_code"`
	SenderFee                sql.NullFloat64       `json:"sender_fee"`
	SenderFeePercentage      sql.NullFloat64       `json:"sender_fee_percentage"`
	SupportsPreOrder         sql.NullBool          `json:"supports_pre_order"`
	LogoUrl                  sql.NullString        `json:"logo_url"`
	BrandName                sql.NullString        `json:"brand_name"`
	CategoryName             sql.NullString        `json:"category_name"`
	CountryName              sql.NullString        `json:"country_name"`
	FlagUrl                  sql.NullString        `json:"flag_url"`
}

func (q *Queries) FetchGiftCard(ctx context.Context, productID int64) (FetchGiftCardRow, error) {
	row := q.db.QueryRowContext(ctx, fetchGiftCard, productID)
	var i FetchGiftCardRow
	err := row.Scan(
		&i.ProductID,
		&i.ProductName,
		&i.DenominationType,
		&i.DiscountPercentage,
		&i.MaxRecipientDenomination,
		&i.MinRecipientDenomination,
		&i.MaxSenderDenomination,
		&i.MinSenderDenomination,
		&i.Global,
		&i.Metadata,
		&i.RecipientCurrencyCode,
		&i.SenderCurrencyCode,
		&i.SenderFee,
		&i.SenderFeePercentage,
		&i.SupportsPreOrder,
		&i.LogoUrl,
		&i.BrandName,
		&i.CategoryName,
		&i.CountryName,
		&i.FlagUrl,
	)
	return i, err
}

const fetchGiftCards = `-- name: FetchGiftCards :many
SELECT 
    gc.id,
    gc.product_id, 
    gc.product_name, 
    gc.denomination_type, 
    gc.discount_percentage, 
    gc.max_recipient_denomination, 
    gc.min_recipient_denomination, 
    gc.max_sender_denomination, 
    gc.min_sender_denomination, 
    -- This ensures that only payable denom in 'USD' is returned
    COALESCE(
        JSON_AGG(DISTINCT gd.denomination) FILTER (WHERE gd.denomination IS NOT NULL AND gd.type = 'sender'),
        '[]'
    )::json AS giftcard_denominations,
    gc.global, 
    gc.metadata, 
    gc.recipient_currency_code, 
    gc.sender_currency_code, 
    gc.sender_fee, 
    gc.sender_fee_percentage, 
    gc.supports_pre_order, 
    COALESCE(JSON_AGG(DISTINCT gl.logo_url) FILTER (WHERE gl.logo_url IS NOT NULL), '[]')::json AS logo_urls,
    b.brand_name, 
    c.name AS category_name,
    co.name AS country_name, 
    co.flag_url
FROM 
    gift_cards gc
LEFT JOIN 
    brands b ON gc.brand_id = b.brand_id
LEFT JOIN 
    gift_card_fixed_denominations gd ON gc.id = gd.gift_card_id
LEFT JOIN 
    categories c ON gc.category_id = c.id
LEFT JOIN 
    countries co ON gc.country_id = co.id
LEFT JOIN 
    gift_card_logo_urls gl ON gc.id = gl.gift_card_id 
GROUP BY 
    gc.id,
    gc.product_id, 
    gc.product_name, 
    gc.denomination_type, 
    gc.discount_percentage, 
    gc.max_recipient_denomination, 
    gc.min_recipient_denomination, 
    gc.max_sender_denomination, 
    gc.min_sender_denomination, 
    gc.global, 
    gc.metadata, 
    gc.recipient_currency_code, 
    gc.sender_currency_code, 
    gc.sender_fee, 
    gc.sender_fee_percentage, 
    gc.supports_pre_order, 
    b.brand_name, 
    c.name, 
    co.name, 
    co.flag_url
ORDER BY 
    gc.product_id
`

type FetchGiftCardsRow struct {
	ID                       int32                 `json:"id"`
	ProductID                int64                 `json:"product_id"`
	ProductName              sql.NullString        `json:"product_name"`
	DenominationType         sql.NullString        `json:"denomination_type"`
	DiscountPercentage       sql.NullFloat64       `json:"discount_percentage"`
	MaxRecipientDenomination sql.NullFloat64       `json:"max_recipient_denomination"`
	MinRecipientDenomination sql.NullFloat64       `json:"min_recipient_denomination"`
	MaxSenderDenomination    sql.NullFloat64       `json:"max_sender_denomination"`
	MinSenderDenomination    sql.NullFloat64       `json:"min_sender_denomination"`
	GiftcardDenominations    json.RawMessage       `json:"giftcard_denominations"`
	Global                   sql.NullBool          `json:"global"`
	Metadata                 pqtype.NullRawMessage `json:"metadata"`
	RecipientCurrencyCode    sql.NullString        `json:"recipient_currency_code"`
	SenderCurrencyCode       sql.NullString        `json:"sender_currency_code"`
	SenderFee                sql.NullFloat64       `json:"sender_fee"`
	SenderFeePercentage      sql.NullFloat64       `json:"sender_fee_percentage"`
	SupportsPreOrder         sql.NullBool          `json:"supports_pre_order"`
	LogoUrls                 json.RawMessage       `json:"logo_urls"`
	BrandName                sql.NullString        `json:"brand_name"`
	CategoryName             sql.NullString        `json:"category_name"`
	CountryName              sql.NullString        `json:"country_name"`
	FlagUrl                  sql.NullString        `json:"flag_url"`
}

func (q *Queries) FetchGiftCards(ctx context.Context) ([]FetchGiftCardsRow, error) {
	rows, err := q.db.QueryContext(ctx, fetchGiftCards)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FetchGiftCardsRow{}
	for rows.Next() {
		var i FetchGiftCardsRow
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.ProductName,
			&i.DenominationType,
			&i.DiscountPercentage,
			&i.MaxRecipientDenomination,
			&i.MinRecipientDenomination,
			&i.MaxSenderDenomination,
			&i.MinSenderDenomination,
			&i.GiftcardDenominations,
			&i.Global,
			&i.Metadata,
			&i.RecipientCurrencyCode,
			&i.SenderCurrencyCode,
			&i.SenderFee,
			&i.SenderFeePercentage,
			&i.SupportsPreOrder,
			&i.LogoUrls,
			&i.BrandName,
			&i.CategoryName,
			&i.CountryName,
			&i.FlagUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchGiftCardsByBrand = `-- name: FetchGiftCardsByBrand :many
SELECT 
    b.id,
    b.brand_id,
    b.brand_name,
    (
        SELECT logo_url 
        FROM gift_card_logo_urls gl 
        JOIN gift_cards gc2 ON gl.gift_card_id = gc2.id
        WHERE gc2.brand_id = b.id
        LIMIT 1
    ) AS brand_logo_url,
    COUNT(gc.id) AS gift_card_count
FROM 
    brands b
LEFT JOIN 
    gift_cards gc ON b.id = gc.brand_id
GROUP BY 
    b.id,
    b.brand_id,
    b.brand_name
ORDER BY 
    b.brand_name ASC
`

type FetchGiftCardsByBrandRow struct {
	ID            int32          `json:"id"`
	BrandID       int64          `json:"brand_id"`
	BrandName     sql.NullString `json:"brand_name"`
	BrandLogoUrl  sql.NullString `json:"brand_logo_url"`
	GiftCardCount int64          `json:"gift_card_count"`
}

func (q *Queries) FetchGiftCardsByBrand(ctx context.Context) ([]FetchGiftCardsByBrandRow, error) {
	rows, err := q.db.QueryContext(ctx, fetchGiftCardsByBrand)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FetchGiftCardsByBrandRow{}
	for rows.Next() {
		var i FetchGiftCardsByBrandRow
		if err := rows.Scan(
			&i.ID,
			&i.BrandID,
			&i.BrandName,
			&i.BrandLogoUrl,
			&i.GiftCardCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchGiftCardsByCategory = `-- name: FetchGiftCardsByCategory :many
SELECT 
    c.name,
    COUNT(DISTINCT gc.id) AS gift_card_count,
    COALESCE(
        JSON_AGG(
            DISTINCT jsonb_build_object(
                'id', b.id,
                'brand_id', b.brand_id,
                'brand_name', b.brand_name,
                'brand_logo_url', gl.logo_url
            )
        ) FILTER (WHERE b.brand_id IS NOT NULL),
        '[]'
    )::json AS brands
FROM 
    categories c 
LEFT JOIN
    gift_cards gc ON gc.category_id = c.id
LEFT JOIN
    brands b ON gc.brand_id = b.id
LEFT JOIN
    gift_card_logo_urls gl ON gc.id = gl.gift_card_id
GROUP BY 
    c.id,
    c.category_id,
    c.name
ORDER BY 
    c.name
`

type FetchGiftCardsByCategoryRow struct {
	Name          string          `json:"name"`
	GiftCardCount int64           `json:"gift_card_count"`
	Brands        json.RawMessage `json:"brands"`
}

func (q *Queries) FetchGiftCardsByCategory(ctx context.Context) ([]FetchGiftCardsByCategoryRow, error) {
	rows, err := q.db.QueryContext(ctx, fetchGiftCardsByCategory)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FetchGiftCardsByCategoryRow{}
	for rows.Next() {
		var i FetchGiftCardsByCategoryRow
		if err := rows.Scan(&i.Name, &i.GiftCardCount, &i.Brands); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listGiftCards = `-- name: ListGiftCards :many
SELECT 
    gc.product_name AS name,
    gd.denomination AS value,
    gc.recipient_currency_code AS currency,
    gc.discount_percentage AS purchase_rate,
    COALESCE((100 - gc.discount_percentage), 0)::NUMERIC AS sale_rate, -- Ensure sale_rate is never NULL
    CASE 
        WHEN gc.global THEN 'Active'
        ELSE 'Inactive'
    END AS status,
    gc.global AS activate_deactivate
FROM 
    gift_cards gc
LEFT JOIN 
    gift_card_fixed_denominations gd ON gc.id = gd.gift_card_id
ORDER BY 
    gc.product_name ASC
`

type ListGiftCardsRow struct {
	Name               sql.NullString  `json:"name"`
	Value              sql.NullFloat64 `json:"value"`
	Currency           sql.NullString  `json:"currency"`
	PurchaseRate       sql.NullFloat64 `json:"purchase_rate"`
	SaleRate           string          `json:"sale_rate"`
	Status             string          `json:"status"`
	ActivateDeactivate sql.NullBool    `json:"activate_deactivate"`
}

func (q *Queries) ListGiftCards(ctx context.Context) ([]ListGiftCardsRow, error) {
	rows, err := q.db.QueryContext(ctx, listGiftCards)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListGiftCardsRow{}
	for rows.Next() {
		var i ListGiftCardsRow
		if err := rows.Scan(
			&i.Name,
			&i.Value,
			&i.Currency,
			&i.PurchaseRate,
			&i.SaleRate,
			&i.Status,
			&i.ActivateDeactivate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectCountriesByBrandID = `-- name: SelectCountriesByBrandID :many
SELECT country_id, product_name
FROM 
    gift_cards
WHERE 
    brand_id = $1
`

type SelectCountriesByBrandIDRow struct {
	CountryID   sql.NullInt64  `json:"country_id"`
	ProductName sql.NullString `json:"product_name"`
}

func (q *Queries) SelectCountriesByBrandID(ctx context.Context, brandID sql.NullInt64) ([]SelectCountriesByBrandIDRow, error) {
	rows, err := q.db.QueryContext(ctx, selectCountriesByBrandID, brandID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SelectCountriesByBrandIDRow{}
	for rows.Next() {
		var i SelectCountriesByBrandIDRow
		if err := rows.Scan(&i.CountryID, &i.ProductName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectGiftCardsByCountryIDAndBrandID = `-- name: SelectGiftCardsByCountryIDAndBrandID :many
SELECT 
    gc.id,
    gc.product_id, 
    gc.product_name, 
    gc.denomination_type, 
    gc.discount_percentage, 
    gc.max_recipient_denomination, 
    gc.min_recipient_denomination, 
    gc.max_sender_denomination, 
    gc.min_sender_denomination,
    COALESCE(
        JSON_AGG(DISTINCT gd.denomination) FILTER (WHERE gd.denomination IS NOT NULL AND gd.type = 'sender'),
        '[]'
    )::json AS giftcard_denominations,
    gc.global, 
    gc.metadata, 
    gc.recipient_currency_code, 
    gc.sender_currency_code, 
    gc.sender_fee, 
    gc.sender_fee_percentage, 
    gc.supports_pre_order,
    COALESCE(JSON_AGG(DISTINCT gl.logo_url) FILTER (WHERE gl.logo_url IS NOT NULL), '[]')::json AS logo_urls,
    b.brand_name,
    c.name AS category_name,
    co.name AS country_name,
    co.flag_url
FROM 
    gift_cards gc
LEFT JOIN 
    brands b ON gc.brand_id = b.brand_id
LEFT JOIN 
    gift_card_fixed_denominations gd ON gc.id = gd.gift_card_id
LEFT JOIN 
    categories c ON gc.category_id = c.id
LEFT JOIN 
    countries co ON gc.country_id = co.id
LEFT JOIN 
    gift_card_logo_urls gl ON gc.id = gl.gift_card_id
WHERE
    gc.country_id = $1 AND gc.brand_id = $2
GROUP BY 
    gc.id,
    gc.product_id, 
    gc.product_name, 
    gc.denomination_type, 
    gc.discount_percentage, 
    gc.max_recipient_denomination, 
    gc.min_recipient_denomination, 
    gc.max_sender_denomination, 
    gc.min_sender_denomination, 
    gc.global, 
    gc.metadata, 
    gc.recipient_currency_code, 
    gc.sender_currency_code, 
    gc.sender_fee, 
    gc.sender_fee_percentage, 
    gc.supports_pre_order, 
    b.brand_name, 
    c.name, 
    co.name, 
    co.flag_url
ORDER BY 
    gc.product_id
`

type SelectGiftCardsByCountryIDAndBrandIDParams struct {
	CountryID sql.NullInt64 `json:"country_id"`
	BrandID   sql.NullInt64 `json:"brand_id"`
}

type SelectGiftCardsByCountryIDAndBrandIDRow struct {
	ID                       int32                 `json:"id"`
	ProductID                int64                 `json:"product_id"`
	ProductName              sql.NullString        `json:"product_name"`
	DenominationType         sql.NullString        `json:"denomination_type"`
	DiscountPercentage       sql.NullFloat64       `json:"discount_percentage"`
	MaxRecipientDenomination sql.NullFloat64       `json:"max_recipient_denomination"`
	MinRecipientDenomination sql.NullFloat64       `json:"min_recipient_denomination"`
	MaxSenderDenomination    sql.NullFloat64       `json:"max_sender_denomination"`
	MinSenderDenomination    sql.NullFloat64       `json:"min_sender_denomination"`
	GiftcardDenominations    json.RawMessage       `json:"giftcard_denominations"`
	Global                   sql.NullBool          `json:"global"`
	Metadata                 pqtype.NullRawMessage `json:"metadata"`
	RecipientCurrencyCode    sql.NullString        `json:"recipient_currency_code"`
	SenderCurrencyCode       sql.NullString        `json:"sender_currency_code"`
	SenderFee                sql.NullFloat64       `json:"sender_fee"`
	SenderFeePercentage      sql.NullFloat64       `json:"sender_fee_percentage"`
	SupportsPreOrder         sql.NullBool          `json:"supports_pre_order"`
	LogoUrls                 json.RawMessage       `json:"logo_urls"`
	BrandName                sql.NullString        `json:"brand_name"`
	CategoryName             sql.NullString        `json:"category_name"`
	CountryName              sql.NullString        `json:"country_name"`
	FlagUrl                  sql.NullString        `json:"flag_url"`
}

func (q *Queries) SelectGiftCardsByCountryIDAndBrandID(ctx context.Context, arg SelectGiftCardsByCountryIDAndBrandIDParams) ([]SelectGiftCardsByCountryIDAndBrandIDRow, error) {
	rows, err := q.db.QueryContext(ctx, selectGiftCardsByCountryIDAndBrandID, arg.CountryID, arg.BrandID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SelectGiftCardsByCountryIDAndBrandIDRow{}
	for rows.Next() {
		var i SelectGiftCardsByCountryIDAndBrandIDRow
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.ProductName,
			&i.DenominationType,
			&i.DiscountPercentage,
			&i.MaxRecipientDenomination,
			&i.MinRecipientDenomination,
			&i.MaxSenderDenomination,
			&i.MinSenderDenomination,
			&i.GiftcardDenominations,
			&i.Global,
			&i.Metadata,
			&i.RecipientCurrencyCode,
			&i.SenderCurrencyCode,
			&i.SenderFee,
			&i.SenderFeePercentage,
			&i.SupportsPreOrder,
			&i.LogoUrls,
			&i.BrandName,
			&i.CategoryName,
			&i.CountryName,
			&i.FlagUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertBrand = `-- name: UpsertBrand :one
INSERT INTO brands (brand_id, brand_name)
VALUES ($1, $2)
ON CONFLICT (brand_id) DO UPDATE SET brand_name = EXCLUDED.brand_name
RETURNING id
`

type UpsertBrandParams struct {
	BrandID   int64          `json:"brand_id"`
	BrandName sql.NullString `json:"brand_name"`
}

func (q *Queries) UpsertBrand(ctx context.Context, arg UpsertBrandParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, upsertBrand, arg.BrandID, arg.BrandName)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const upsertCategory = `-- name: UpsertCategory :one
INSERT INTO categories (category_id, name)
VALUES ($1, $2)
ON CONFLICT (category_id) DO UPDATE SET name = EXCLUDED.name
RETURNING id
`

type UpsertCategoryParams struct {
	CategoryID int64  `json:"category_id"`
	Name       string `json:"name"`
}

func (q *Queries) UpsertCategory(ctx context.Context, arg UpsertCategoryParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, upsertCategory, arg.CategoryID, arg.Name)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const upsertCountry = `-- name: UpsertCountry :one
INSERT INTO countries (iso_name, name, flag_url)
VALUES ($1, $2, $3)
ON CONFLICT (iso_name) DO UPDATE SET name = EXCLUDED.name, flag_url = EXCLUDED.flag_url
RETURNING id
`

type UpsertCountryParams struct {
	IsoName sql.NullString `json:"iso_name"`
	Name    sql.NullString `json:"name"`
	FlagUrl sql.NullString `json:"flag_url"`
}

func (q *Queries) UpsertCountry(ctx context.Context, arg UpsertCountryParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, upsertCountry, arg.IsoName, arg.Name, arg.FlagUrl)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const upsertFixedDenominations = `-- name: UpsertFixedDenominations :exec
INSERT INTO gift_card_fixed_denominations (gift_card_id, type, denomination)
VALUES ($1, $2, $3)
ON CONFLICT DO NOTHING
`

type UpsertFixedDenominationsParams struct {
	GiftCardID   sql.NullInt64   `json:"gift_card_id"`
	Type         sql.NullString  `json:"type"`
	Denomination sql.NullFloat64 `json:"denomination"`
}

func (q *Queries) UpsertFixedDenominations(ctx context.Context, arg UpsertFixedDenominationsParams) error {
	_, err := q.db.ExecContext(ctx, upsertFixedDenominations, arg.GiftCardID, arg.Type, arg.Denomination)
	return err
}

const upsertGiftCard = `-- name: UpsertGiftCard :one
INSERT INTO gift_cards (
    product_id, product_name, denomination_type, discount_percentage, 
    max_recipient_denomination, min_recipient_denomination, 
    max_sender_denomination, min_sender_denomination, global, metadata, 
    recipient_currency_code, sender_currency_code, sender_fee, 
    sender_fee_percentage, supports_pre_order, brand_id, category_id, country_id
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18)
ON CONFLICT (product_id) DO UPDATE SET
    product_name = EXCLUDED.product_name, 
    denomination_type = EXCLUDED.denomination_type,
    discount_percentage = EXCLUDED.discount_percentage,
    max_recipient_denomination = EXCLUDED.max_recipient_denomination,
    min_recipient_denomination = EXCLUDED.min_recipient_denomination,
    max_sender_denomination = EXCLUDED.max_sender_denomination, 
    min_sender_denomination = EXCLUDED.min_sender_denomination,
    global = EXCLUDED.global,
    metadata = EXCLUDED.metadata,
    recipient_currency_code = EXCLUDED.recipient_currency_code,
    sender_currency_code = EXCLUDED.sender_currency_code,
    sender_fee = EXCLUDED.sender_fee,
    sender_fee_percentage = EXCLUDED.sender_fee_percentage,
    supports_pre_order = EXCLUDED.supports_pre_order,
    brand_id = EXCLUDED.brand_id,
    category_id = EXCLUDED.category_id,
    country_id = EXCLUDED.country_id
RETURNING id
`

type UpsertGiftCardParams struct {
	ProductID                int64                 `json:"product_id"`
	ProductName              sql.NullString        `json:"product_name"`
	DenominationType         sql.NullString        `json:"denomination_type"`
	DiscountPercentage       sql.NullFloat64       `json:"discount_percentage"`
	MaxRecipientDenomination sql.NullFloat64       `json:"max_recipient_denomination"`
	MinRecipientDenomination sql.NullFloat64       `json:"min_recipient_denomination"`
	MaxSenderDenomination    sql.NullFloat64       `json:"max_sender_denomination"`
	MinSenderDenomination    sql.NullFloat64       `json:"min_sender_denomination"`
	Global                   sql.NullBool          `json:"global"`
	Metadata                 pqtype.NullRawMessage `json:"metadata"`
	RecipientCurrencyCode    sql.NullString        `json:"recipient_currency_code"`
	SenderCurrencyCode       sql.NullString        `json:"sender_currency_code"`
	SenderFee                sql.NullFloat64       `json:"sender_fee"`
	SenderFeePercentage      sql.NullFloat64       `json:"sender_fee_percentage"`
	SupportsPreOrder         sql.NullBool          `json:"supports_pre_order"`
	BrandID                  sql.NullInt64         `json:"brand_id"`
	CategoryID               sql.NullInt64         `json:"category_id"`
	CountryID                sql.NullInt64         `json:"country_id"`
}

func (q *Queries) UpsertGiftCard(ctx context.Context, arg UpsertGiftCardParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, upsertGiftCard,
		arg.ProductID,
		arg.ProductName,
		arg.DenominationType,
		arg.DiscountPercentage,
		arg.MaxRecipientDenomination,
		arg.MinRecipientDenomination,
		arg.MaxSenderDenomination,
		arg.MinSenderDenomination,
		arg.Global,
		arg.Metadata,
		arg.RecipientCurrencyCode,
		arg.SenderCurrencyCode,
		arg.SenderFee,
		arg.SenderFeePercentage,
		arg.SupportsPreOrder,
		arg.BrandID,
		arg.CategoryID,
		arg.CountryID,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const upsertGiftCardLogoUrl = `-- name: UpsertGiftCardLogoUrl :exec
INSERT INTO gift_card_logo_urls (gift_card_id, logo_url)
VALUES ($1, $2)
ON CONFLICT DO NOTHING
`

type UpsertGiftCardLogoUrlParams struct {
	GiftCardID sql.NullInt64  `json:"gift_card_id"`
	LogoUrl    sql.NullString `json:"logo_url"`
}

func (q *Queries) UpsertGiftCardLogoUrl(ctx context.Context, arg UpsertGiftCardLogoUrlParams) error {
	_, err := q.db.ExecContext(ctx, upsertGiftCardLogoUrl, arg.GiftCardID, arg.LogoUrl)
	return err
}

const upsertRedeemInstructions = `-- name: UpsertRedeemInstructions :exec
INSERT INTO redeem_instructions (gift_card_id, concise, detailed_instruction)
VALUES ($1, $2, $3)
ON CONFLICT (gift_card_id) DO UPDATE SET
concise = EXCLUDED.concise,
detailed_instruction = EXCLUDED.detailed_instruction
`

type UpsertRedeemInstructionsParams struct {
	GiftCardID          sql.NullInt64  `json:"gift_card_id"`
	Concise             sql.NullString `json:"concise"`
	DetailedInstruction sql.NullString `json:"detailed_instruction"`
}

func (q *Queries) UpsertRedeemInstructions(ctx context.Context, arg UpsertRedeemInstructionsParams) error {
	_, err := q.db.ExecContext(ctx, upsertRedeemInstructions, arg.GiftCardID, arg.Concise, arg.DetailedInstruction)
	return err
}
