// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: wallet.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const createWallet = `-- name: CreateWallet :one
INSERT INTO swift_wallets (
    customer_id,
    type,
    currency,
    balance
) VALUES (
    $1, $2, $3, $4
) RETURNING id, customer_id, type, currency, balance, status, created_at, updated_at
`

type CreateWalletParams struct {
	CustomerID int64          `json:"customer_id"`
	Type       string         `json:"type"`
	Currency   string         `json:"currency"`
	Balance    sql.NullString `json:"balance"`
}

func (q *Queries) CreateWallet(ctx context.Context, arg CreateWalletParams) (SwiftWallet, error) {
	row := q.db.QueryRowContext(ctx, createWallet,
		arg.CustomerID,
		arg.Type,
		arg.Currency,
		arg.Balance,
	)
	var i SwiftWallet
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.Type,
		&i.Currency,
		&i.Balance,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getWallet = `-- name: GetWallet :one
SELECT id, customer_id, type, currency, balance, status, created_at, updated_at FROM swift_wallets
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetWallet(ctx context.Context, id uuid.UUID) (SwiftWallet, error) {
	row := q.db.QueryRowContext(ctx, getWallet, id)
	var i SwiftWallet
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.Type,
		&i.Currency,
		&i.Balance,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getWalletByCurrency = `-- name: GetWalletByCurrency :one
SELECT id, customer_id, type, currency, balance, status, created_at, updated_at FROM swift_wallets
WHERE customer_id = $1 AND currency = $2 LIMIT 1
`

type GetWalletByCurrencyParams struct {
	CustomerID int64  `json:"customer_id"`
	Currency   string `json:"currency"`
}

func (q *Queries) GetWalletByCurrency(ctx context.Context, arg GetWalletByCurrencyParams) (SwiftWallet, error) {
	row := q.db.QueryRowContext(ctx, getWalletByCurrency, arg.CustomerID, arg.Currency)
	var i SwiftWallet
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.Type,
		&i.Currency,
		&i.Balance,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getWalletByCurrencyForUpdate = `-- name: GetWalletByCurrencyForUpdate :one
SELECT id, customer_id, type, currency, balance, status, created_at, updated_at FROM swift_wallets
WHERE customer_id = $1 AND currency = $2 LIMIT 1
FOR UPDATE
`

type GetWalletByCurrencyForUpdateParams struct {
	CustomerID int64  `json:"customer_id"`
	Currency   string `json:"currency"`
}

func (q *Queries) GetWalletByCurrencyForUpdate(ctx context.Context, arg GetWalletByCurrencyForUpdateParams) (SwiftWallet, error) {
	row := q.db.QueryRowContext(ctx, getWalletByCurrencyForUpdate, arg.CustomerID, arg.Currency)
	var i SwiftWallet
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.Type,
		&i.Currency,
		&i.Balance,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getWalletByCustomerID = `-- name: GetWalletByCustomerID :many
SELECT id, customer_id, type, currency, balance, status, created_at, updated_at FROM swift_wallets
WHERE customer_id = $1
`

func (q *Queries) GetWalletByCustomerID(ctx context.Context, customerID int64) ([]SwiftWallet, error) {
	rows, err := q.db.QueryContext(ctx, getWalletByCustomerID, customerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SwiftWallet{}
	for rows.Next() {
		var i SwiftWallet
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.Type,
			&i.Currency,
			&i.Balance,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWalletByTag = `-- name: GetWalletByTag :one
SELECT sw.id, sw.currency, sw.status ,u.id, u.first_name, u.last_name
FROM users u
JOIN swift_wallets sw ON u.id = sw.customer_id
WHERE u.user_tag = $1 AND u.deleted_at IS NULL AND sw.currency = $2
`

type GetWalletByTagParams struct {
	UserTag  sql.NullString `json:"user_tag"`
	Currency string         `json:"currency"`
}

type GetWalletByTagRow struct {
	ID        uuid.UUID      `json:"id"`
	Currency  string         `json:"currency"`
	Status    string         `json:"status"`
	ID_2      int64          `json:"id_2"`
	FirstName sql.NullString `json:"first_name"`
	LastName  sql.NullString `json:"last_name"`
}

func (q *Queries) GetWalletByTag(ctx context.Context, arg GetWalletByTagParams) (GetWalletByTagRow, error) {
	row := q.db.QueryRowContext(ctx, getWalletByTag, arg.UserTag, arg.Currency)
	var i GetWalletByTagRow
	err := row.Scan(
		&i.ID,
		&i.Currency,
		&i.Status,
		&i.ID_2,
		&i.FirstName,
		&i.LastName,
	)
	return i, err
}

const getWalletForUpdate = `-- name: GetWalletForUpdate :one
SELECT id, customer_id, type, currency, balance, status, created_at, updated_at FROM swift_wallets
WHERE id = $1 LIMIT 1
FOR UPDATE
`

func (q *Queries) GetWalletForUpdate(ctx context.Context, id uuid.UUID) (SwiftWallet, error) {
	row := q.db.QueryRowContext(ctx, getWalletForUpdate, id)
	var i SwiftWallet
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.Type,
		&i.Currency,
		&i.Balance,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listWallets = `-- name: ListWallets :many
SELECT id, customer_id, type, currency, balance, status, created_at, updated_at FROM swift_wallets
WHERE customer_id = $1
ORDER BY created_at
`

func (q *Queries) ListWallets(ctx context.Context, customerID int64) ([]SwiftWallet, error) {
	rows, err := q.db.QueryContext(ctx, listWallets, customerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SwiftWallet{}
	for rows.Next() {
		var i SwiftWallet
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.Type,
			&i.Currency,
			&i.Balance,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateWalletBalance = `-- name: UpdateWalletBalance :one
UPDATE swift_wallets 
SET balance = balance + $1
WHERE id = $2
RETURNING id, customer_id, type, currency, balance, status, created_at, updated_at
`

type UpdateWalletBalanceParams struct {
	Amount sql.NullString `json:"amount"`
	ID     uuid.UUID      `json:"id"`
}

func (q *Queries) UpdateWalletBalance(ctx context.Context, arg UpdateWalletBalanceParams) (SwiftWallet, error) {
	row := q.db.QueryRowContext(ctx, updateWalletBalance, arg.Amount, arg.ID)
	var i SwiftWallet
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.Type,
		&i.Currency,
		&i.Balance,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
