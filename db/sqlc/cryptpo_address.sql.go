// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: cryptpo_address.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const assignAddressToCustomer = `-- name: AssignAddressToCustomer :one
INSERT INTO crypto_addresses (customer_id, address_id, coin, balance, status)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, customer_id, address_id, coin, balance, status, created_at, updated_at
`

type AssignAddressToCustomerParams struct {
	CustomerID sql.NullInt64  `json:"customer_id"`
	AddressID  string         `json:"address_id"`
	Coin       string         `json:"coin"`
	Balance    sql.NullString `json:"balance"`
	Status     string         `json:"status"`
}

func (q *Queries) AssignAddressToCustomer(ctx context.Context, arg AssignAddressToCustomerParams) (CryptoAddress, error) {
	row := q.db.QueryRowContext(ctx, assignAddressToCustomer,
		arg.CustomerID,
		arg.AddressID,
		arg.Coin,
		arg.Balance,
		arg.Status,
	)
	var i CryptoAddress
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.AddressID,
		&i.Coin,
		&i.Balance,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deactivateAddressByID = `-- name: DeactivateAddressByID :one
UPDATE crypto_addresses
SET status = 'inactive',
    updated_at = NOW()
WHERE address_id = $1
RETURNING id, customer_id, address_id, coin, balance, status, created_at, updated_at
`

func (q *Queries) DeactivateAddressByID(ctx context.Context, addressID string) (CryptoAddress, error) {
	row := q.db.QueryRowContext(ctx, deactivateAddressByID, addressID)
	var i CryptoAddress
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.AddressID,
		&i.Coin,
		&i.Balance,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const fetchActiveByCustomerID = `-- name: FetchActiveByCustomerID :many
SELECT id, customer_id, address_id, coin, balance, status, created_at, updated_at
FROM crypto_addresses
WHERE customer_id = $1 AND status = 'active'
`

func (q *Queries) FetchActiveByCustomerID(ctx context.Context, customerID sql.NullInt64) ([]CryptoAddress, error) {
	rows, err := q.db.QueryContext(ctx, fetchActiveByCustomerID, customerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CryptoAddress{}
	for rows.Next() {
		var i CryptoAddress
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.AddressID,
			&i.Coin,
			&i.Balance,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchAllAddressesAndCustomers = `-- name: FetchAllAddressesAndCustomers :many
SELECT 
    ca.id AS address_id, 
    ca.customer_id, 
    ca.coin, 
    ca.balance, 
    ca.status, 
    u.first_name AS customer_name, 
    u.email AS customer_email
FROM crypto_addresses ca
LEFT JOIN users u ON ca.customer_id = u.id
`

type FetchAllAddressesAndCustomersRow struct {
	AddressID     uuid.UUID      `json:"address_id"`
	CustomerID    sql.NullInt64  `json:"customer_id"`
	Coin          string         `json:"coin"`
	Balance       sql.NullString `json:"balance"`
	Status        string         `json:"status"`
	CustomerName  sql.NullString `json:"customer_name"`
	CustomerEmail sql.NullString `json:"customer_email"`
}

func (q *Queries) FetchAllAddressesAndCustomers(ctx context.Context) ([]FetchAllAddressesAndCustomersRow, error) {
	rows, err := q.db.QueryContext(ctx, fetchAllAddressesAndCustomers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FetchAllAddressesAndCustomersRow{}
	for rows.Next() {
		var i FetchAllAddressesAndCustomersRow
		if err := rows.Scan(
			&i.AddressID,
			&i.CustomerID,
			&i.Coin,
			&i.Balance,
			&i.Status,
			&i.CustomerName,
			&i.CustomerEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchByAddressID = `-- name: FetchByAddressID :one
SELECT id, customer_id, address_id, coin, balance, status, created_at, updated_at
FROM crypto_addresses
WHERE address_id = $1
`

func (q *Queries) FetchByAddressID(ctx context.Context, addressID string) (CryptoAddress, error) {
	row := q.db.QueryRowContext(ctx, fetchByAddressID, addressID)
	var i CryptoAddress
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.AddressID,
		&i.Coin,
		&i.Balance,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findTopCustomersByBalance = `-- name: FindTopCustomersByBalance :many
SELECT customer_id, SUM(balance) AS total_balance
FROM crypto_addresses
WHERE customer_id IS NOT NULL
GROUP BY customer_id
ORDER BY total_balance DESC
LIMIT $1
`

type FindTopCustomersByBalanceRow struct {
	CustomerID   sql.NullInt64 `json:"customer_id"`
	TotalBalance int64         `json:"total_balance"`
}

func (q *Queries) FindTopCustomersByBalance(ctx context.Context, limit int32) ([]FindTopCustomersByBalanceRow, error) {
	rows, err := q.db.QueryContext(ctx, findTopCustomersByBalance, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FindTopCustomersByBalanceRow{}
	for rows.Next() {
		var i FindTopCustomersByBalanceRow
		if err := rows.Scan(&i.CustomerID, &i.TotalBalance); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrphanedAddresses = `-- name: GetOrphanedAddresses :many
SELECT id, customer_id, address_id, coin, balance, status, created_at, updated_at
FROM crypto_addresses
WHERE customer_id IS NULL
`

func (q *Queries) GetOrphanedAddresses(ctx context.Context) ([]CryptoAddress, error) {
	rows, err := q.db.QueryContext(ctx, getOrphanedAddresses)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CryptoAddress{}
	for rows.Next() {
		var i CryptoAddress
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.AddressID,
			&i.Coin,
			&i.Balance,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAddressBalanceByAddressID = `-- name: UpdateAddressBalanceByAddressID :one
UPDATE crypto_addresses
SET balance = balance + $2,
    updated_at = NOW()
WHERE address_id = $1
RETURNING id, customer_id, address_id, coin, balance, status, created_at, updated_at
`

type UpdateAddressBalanceByAddressIDParams struct {
	AddressID string         `json:"address_id"`
	Balance   sql.NullString `json:"balance"`
}

func (q *Queries) UpdateAddressBalanceByAddressID(ctx context.Context, arg UpdateAddressBalanceByAddressIDParams) (CryptoAddress, error) {
	row := q.db.QueryRowContext(ctx, updateAddressBalanceByAddressID, arg.AddressID, arg.Balance)
	var i CryptoAddress
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.AddressID,
		&i.Coin,
		&i.Balance,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
