// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: wallet_queries.sql

package db

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"

	"github.com/google/uuid"
)

const createWallet = `-- name: CreateWallet :one
INSERT INTO swift_wallets (
    customer_id,
    type,
    currency,
    balance
) VALUES (
    $1, $2, $3, $4
) RETURNING id, customer_id, type, currency, balance, status, created_at, updated_at
`

type CreateWalletParams struct {
	CustomerID int64          `json:"customer_id"`
	Type       string         `json:"type"`
	Currency   string         `json:"currency"`
	Balance    sql.NullString `json:"balance"`
}

func (q *Queries) CreateWallet(ctx context.Context, arg CreateWalletParams) (SwiftWallet, error) {
	row := q.db.QueryRowContext(ctx, createWallet,
		arg.CustomerID,
		arg.Type,
		arg.Currency,
		arg.Balance,
	)
	var i SwiftWallet
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.Type,
		&i.Currency,
		&i.Balance,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createWalletLedgerEntry = `-- name: CreateWalletLedgerEntry :one
INSERT INTO ledger_entries (
    transaction_id,
    account_id,
    type,
    amount,
    balance
) VALUES (
    $1, $2, $3, $4, $5
) RETURNING id, transaction_id, account_id, type, amount, balance, created_at, deleted_account_id
`

type CreateWalletLedgerEntryParams struct {
	TransactionID uuid.NullUUID `json:"transaction_id"`
	AccountID     uuid.NullUUID `json:"account_id"`
	Type          string        `json:"type"`
	Amount        string        `json:"amount"`
	Balance       string        `json:"balance"`
}

func (q *Queries) CreateWalletLedgerEntry(ctx context.Context, arg CreateWalletLedgerEntryParams) (LedgerEntry, error) {
	row := q.db.QueryRowContext(ctx, createWalletLedgerEntry,
		arg.TransactionID,
		arg.AccountID,
		arg.Type,
		arg.Amount,
		arg.Balance,
	)
	var i LedgerEntry
	err := row.Scan(
		&i.ID,
		&i.TransactionID,
		&i.AccountID,
		&i.Type,
		&i.Amount,
		&i.Balance,
		&i.CreatedAt,
		&i.DeletedAccountID,
	)
	return i, err
}

const createWalletTransaction = `-- name: CreateWalletTransaction :one
INSERT INTO transactions (
    type,
    amount, 
    currency,
    currency_flow,
    from_account_id,
    to_account_id,
    description
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) RETURNING id, type, amount, currency, from_account_id, to_account_id, status, description, created_at, updated_at, currency_flow, deleted_from_account_id, deleted_to_account_id
`

type CreateWalletTransactionParams struct {
	Type          string         `json:"type"`
	Amount        string         `json:"amount"`
	Currency      string         `json:"currency"`
	CurrencyFlow  sql.NullString `json:"currency_flow"`
	FromAccountID uuid.NullUUID  `json:"from_account_id"`
	ToAccountID   uuid.NullUUID  `json:"to_account_id"`
	Description   sql.NullString `json:"description"`
}

func (q *Queries) CreateWalletTransaction(ctx context.Context, arg CreateWalletTransactionParams) (Transaction, error) {
	row := q.db.QueryRowContext(ctx, createWalletTransaction,
		arg.Type,
		arg.Amount,
		arg.Currency,
		arg.CurrencyFlow,
		arg.FromAccountID,
		arg.ToAccountID,
		arg.Description,
	)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Amount,
		&i.Currency,
		&i.FromAccountID,
		&i.ToAccountID,
		&i.Status,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CurrencyFlow,
		&i.DeletedFromAccountID,
		&i.DeletedToAccountID,
	)
	return i, err
}

const getWallet = `-- name: GetWallet :one
SELECT id, customer_id, type, currency, balance, status, created_at, updated_at FROM swift_wallets
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetWallet(ctx context.Context, id uuid.UUID) (SwiftWallet, error) {
	row := q.db.QueryRowContext(ctx, getWallet, id)
	var i SwiftWallet
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.Type,
		&i.Currency,
		&i.Balance,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getWalletByCurrency = `-- name: GetWalletByCurrency :one
SELECT 1 FROM swift_wallets
WHERE customer_id = $1 AND currency = $2
`

type GetWalletByCurrencyParams struct {
	CustomerID int64  `json:"customer_id"`
	Currency   string `json:"currency"`
}

func (q *Queries) GetWalletByCurrency(ctx context.Context, arg GetWalletByCurrencyParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, getWalletByCurrency, arg.CustomerID, arg.Currency)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const getWalletByCurrencyForUpdate = `-- name: GetWalletByCurrencyForUpdate :one
SELECT 1 FROM swift_wallets
WHERE customer_id = $1 AND currency = $2
FOR UPDATE
`

type GetWalletByCurrencyForUpdateParams struct {
	CustomerID int64  `json:"customer_id"`
	Currency   string `json:"currency"`
}

func (q *Queries) GetWalletByCurrencyForUpdate(ctx context.Context, arg GetWalletByCurrencyForUpdateParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, getWalletByCurrencyForUpdate, arg.CustomerID, arg.Currency)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const getWalletByCustomerID = `-- name: GetWalletByCustomerID :many
SELECT id, customer_id, type, currency, balance, status, created_at, updated_at FROM swift_wallets
WHERE customer_id = $1
`

func (q *Queries) GetWalletByCustomerID(ctx context.Context, customerID int64) ([]SwiftWallet, error) {
	rows, err := q.db.QueryContext(ctx, getWalletByCustomerID, customerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SwiftWallet{}
	for rows.Next() {
		var i SwiftWallet
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.Type,
			&i.Currency,
			&i.Balance,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWalletForUpdate = `-- name: GetWalletForUpdate :one
SELECT id, customer_id, type, currency, balance, status, created_at, updated_at FROM swift_wallets
WHERE id = $1 LIMIT 1
FOR UPDATE
`

func (q *Queries) GetWalletForUpdate(ctx context.Context, id uuid.UUID) (SwiftWallet, error) {
	row := q.db.QueryRowContext(ctx, getWalletForUpdate, id)
	var i SwiftWallet
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.Type,
		&i.Currency,
		&i.Balance,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getWalletLedger = `-- name: GetWalletLedger :many
SELECT id, transaction_id, account_id, type, amount, balance, created_at, deleted_account_id FROM ledger_entries
WHERE account_id = $1
ORDER BY created_at DESC
LIMIT $2
OFFSET $3
`

type GetWalletLedgerParams struct {
	AccountID uuid.NullUUID `json:"account_id"`
	Limit     int32         `json:"limit"`
	Offset    int32         `json:"offset"`
}

func (q *Queries) GetWalletLedger(ctx context.Context, arg GetWalletLedgerParams) ([]LedgerEntry, error) {
	rows, err := q.db.QueryContext(ctx, getWalletLedger, arg.AccountID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LedgerEntry{}
	for rows.Next() {
		var i LedgerEntry
		if err := rows.Scan(
			&i.ID,
			&i.TransactionID,
			&i.AccountID,
			&i.Type,
			&i.Amount,
			&i.Balance,
			&i.CreatedAt,
			&i.DeletedAccountID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWalletTransaction = `-- name: GetWalletTransaction :one
SELECT t.id, t.type, t.amount, t.currency, t.from_account_id, t.to_account_id, t.status, t.description, t.created_at, t.updated_at, t.currency_flow, t.deleted_from_account_id, t.deleted_to_account_id, w.id as wallet_id
FROM transactions t
JOIN swift_wallets w ON (t.from_account_id = w.id OR t.to_account_id = w.id)
WHERE t.id = $1 
  AND w.customer_id = $2
LIMIT 1
`

type GetWalletTransactionParams struct {
	ID         uuid.UUID `json:"id"`
	CustomerID int64     `json:"customer_id"`
}

type GetWalletTransactionRow struct {
	ID                   uuid.UUID      `json:"id"`
	Type                 string         `json:"type"`
	Amount               string         `json:"amount"`
	Currency             string         `json:"currency"`
	FromAccountID        uuid.NullUUID  `json:"from_account_id"`
	ToAccountID          uuid.NullUUID  `json:"to_account_id"`
	Status               string         `json:"status"`
	Description          sql.NullString `json:"description"`
	CreatedAt            time.Time      `json:"created_at"`
	UpdatedAt            time.Time      `json:"updated_at"`
	CurrencyFlow         sql.NullString `json:"currency_flow"`
	DeletedFromAccountID uuid.NullUUID  `json:"deleted_from_account_id"`
	DeletedToAccountID   uuid.NullUUID  `json:"deleted_to_account_id"`
	WalletID             uuid.UUID      `json:"wallet_id"`
}

func (q *Queries) GetWalletTransaction(ctx context.Context, arg GetWalletTransactionParams) (GetWalletTransactionRow, error) {
	row := q.db.QueryRowContext(ctx, getWalletTransaction, arg.ID, arg.CustomerID)
	var i GetWalletTransactionRow
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Amount,
		&i.Currency,
		&i.FromAccountID,
		&i.ToAccountID,
		&i.Status,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CurrencyFlow,
		&i.DeletedFromAccountID,
		&i.DeletedToAccountID,
		&i.WalletID,
	)
	return i, err
}

const listWalletTransactions = `-- name: ListWalletTransactions :many
SELECT t.id, t.type, t.amount, t.currency, t.from_account_id, t.to_account_id, t.status, t.description, t.created_at, t.updated_at, t.currency_flow, t.deleted_from_account_id, t.deleted_to_account_id
FROM transactions t
JOIN swift_wallets w ON (t.from_account_id = w.id OR t.to_account_id = w.id)
WHERE 
    (t.from_account_id = $1 OR t.to_account_id = $1)
    AND w.customer_id = $2
ORDER BY t.created_at DESC
LIMIT $3
OFFSET $4
`

type ListWalletTransactionsParams struct {
	FromAccountID uuid.NullUUID `json:"from_account_id"`
	CustomerID    int64         `json:"customer_id"`
	Limit         int32         `json:"limit"`
	Offset        int32         `json:"offset"`
}

func (q *Queries) ListWalletTransactions(ctx context.Context, arg ListWalletTransactionsParams) ([]Transaction, error) {
	rows, err := q.db.QueryContext(ctx, listWalletTransactions,
		arg.FromAccountID,
		arg.CustomerID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Transaction{}
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Amount,
			&i.Currency,
			&i.FromAccountID,
			&i.ToAccountID,
			&i.Status,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CurrencyFlow,
			&i.DeletedFromAccountID,
			&i.DeletedToAccountID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWalletTransactionsByUserID = `-- name: ListWalletTransactionsByUserID :one
WITH transaction_data AS (
    SELECT t.id, t.type, t.amount, t.currency, t.from_account_id, t.to_account_id, t.status, t.description, t.created_at, t.updated_at, t.currency_flow, t.deleted_from_account_id, t.deleted_to_account_id
    FROM transactions t
    JOIN swift_wallets w ON (t.from_account_id = w.id OR t.to_account_id = w.id)
    WHERE 
        w.customer_id = $1
        AND (
            -- If cursor is provided, apply the cursor-based filtering
            -- If no cursor, use the default query to fetch the first results
            ($2::timestamptz IS NULL OR (t.created_at::timestamptz, t.id) < (
                $2::timestamptz,
                $3::uuid
            ))
        )
    ORDER BY t.created_at DESC, t.id DESC
    LIMIT COALESCE($4, 25)
),
last_transaction AS (
    SELECT created_at, id
    FROM transaction_data
    ORDER BY created_at ASC, id ASC
    LIMIT 1
),
has_more_check AS (
    SELECT EXISTS (
        SELECT 1 
        FROM transactions t2
        JOIN swift_wallets w2 ON (t2.from_account_id = w2.id OR t2.to_account_id = w2.id)
        WHERE 
            w2.customer_id = $1
            AND (t2.created_at::timestamptz, t2.id::uuid) < (SELECT created_at::timestamptz, id::uuid FROM last_transaction)
    ) AS has_more
)
SELECT 
    jsonb_build_object(
        'transactions', (SELECT jsonb_agg(td.*) FROM transaction_data td),
        'metadata', jsonb_build_object(
            'has_more', (SELECT has_more FROM has_more_check),
            'next_cursor', (SELECT concat(created_at::timestamptz, '_', id) FROM last_transaction)
        )
    ) AS result
`

type ListWalletTransactionsByUserIDParams struct {
	CustomerID         int64         `json:"customer_id"`
	TransactionCreated sql.NullTime  `json:"transaction_created"`
	TransactionID      uuid.NullUUID `json:"transaction_id"`
	PageLimit          interface{}   `json:"page_limit"`
}

func (q *Queries) ListWalletTransactionsByUserID(ctx context.Context, arg ListWalletTransactionsByUserIDParams) (json.RawMessage, error) {
	row := q.db.QueryRowContext(ctx, listWalletTransactionsByUserID,
		arg.CustomerID,
		arg.TransactionCreated,
		arg.TransactionID,
		arg.PageLimit,
	)
	var result json.RawMessage
	err := row.Scan(&result)
	return result, err
}

const listWallets = `-- name: ListWallets :many
SELECT id, customer_id, type, currency, balance, status, created_at, updated_at FROM swift_wallets
WHERE customer_id = $1
ORDER BY created_at
`

func (q *Queries) ListWallets(ctx context.Context, customerID int64) ([]SwiftWallet, error) {
	rows, err := q.db.QueryContext(ctx, listWallets, customerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SwiftWallet{}
	for rows.Next() {
		var i SwiftWallet
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.Type,
			&i.Currency,
			&i.Balance,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateWalletBalance = `-- name: UpdateWalletBalance :one
UPDATE swift_wallets 
SET balance = balance + $1
WHERE id = $2
RETURNING id, customer_id, type, currency, balance, status, created_at, updated_at
`

type UpdateWalletBalanceParams struct {
	Amount sql.NullString `json:"amount"`
	ID     uuid.UUID      `json:"id"`
}

func (q *Queries) UpdateWalletBalance(ctx context.Context, arg UpdateWalletBalanceParams) (SwiftWallet, error) {
	row := q.db.QueryRowContext(ctx, updateWalletBalance, arg.Amount, arg.ID)
	var i SwiftWallet
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.Type,
		&i.Currency,
		&i.Balance,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateWalletTransactionStatus = `-- name: UpdateWalletTransactionStatus :one
UPDATE transactions
SET status = $2
WHERE id = $1
RETURNING id, type, amount, currency, from_account_id, to_account_id, status, description, created_at, updated_at, currency_flow, deleted_from_account_id, deleted_to_account_id
`

type UpdateWalletTransactionStatusParams struct {
	ID     uuid.UUID `json:"id"`
	Status string    `json:"status"`
}

func (q *Queries) UpdateWalletTransactionStatus(ctx context.Context, arg UpdateWalletTransactionStatusParams) (Transaction, error) {
	row := q.db.QueryRowContext(ctx, updateWalletTransactionStatus, arg.ID, arg.Status)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Amount,
		&i.Currency,
		&i.FromAccountID,
		&i.ToAccountID,
		&i.Status,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CurrencyFlow,
		&i.DeletedFromAccountID,
		&i.DeletedToAccountID,
	)
	return i, err
}
