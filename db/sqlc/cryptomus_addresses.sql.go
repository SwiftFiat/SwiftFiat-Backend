// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: cryptomus_addresses.sql

package db

import (
	"context"
	"database/sql"
)

const deleteCryptomusAddress = `-- name: DeleteCryptomusAddress :exec
DELETE FROM cryptomus_addresses
WHERE address = $1
`

func (q *Queries) DeleteCryptomusAddress(ctx context.Context, address string) error {
	_, err := q.db.ExecContext(ctx, deleteCryptomusAddress, address)
	return err
}

const getCryptomusAddressByAddress = `-- name: GetCryptomusAddressByAddress :one
SELECT id, customer_id, wallet_uuid, uuid, address, network, currency, payment_url, callback_url, status, created_at, updated_at FROM cryptomus_addresses
WHERE address = $1 LIMIT 1
`

func (q *Queries) GetCryptomusAddressByAddress(ctx context.Context, address string) (CryptomusAddress, error) {
	row := q.db.QueryRowContext(ctx, getCryptomusAddressByAddress, address)
	var i CryptomusAddress
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.WalletUuid,
		&i.Uuid,
		&i.Address,
		&i.Network,
		&i.Currency,
		&i.PaymentUrl,
		&i.CallbackUrl,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCryptomusAddressByNetworkAndCurrencyAndCustomerID = `-- name: GetCryptomusAddressByNetworkAndCurrencyAndCustomerID :one
SELECT id, customer_id, wallet_uuid, uuid, address, network, currency, payment_url, callback_url, status, created_at, updated_at FROM cryptomus_addresses
WHERE LOWER(network) = LOWER($1) AND LOWER(currency) = LOWER($2) AND customer_id = $3
LIMIT 1
`

type GetCryptomusAddressByNetworkAndCurrencyAndCustomerIDParams struct {
	Network    sql.NullString `json:"network"`
	Currency   sql.NullString `json:"currency"`
	CustomerID sql.NullInt64  `json:"customer_id"`
}

func (q *Queries) GetCryptomusAddressByNetworkAndCurrencyAndCustomerID(ctx context.Context, arg GetCryptomusAddressByNetworkAndCurrencyAndCustomerIDParams) (CryptomusAddress, error) {
	row := q.db.QueryRowContext(ctx, getCryptomusAddressByNetworkAndCurrencyAndCustomerID, arg.Network, arg.Currency, arg.CustomerID)
	var i CryptomusAddress
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.WalletUuid,
		&i.Uuid,
		&i.Address,
		&i.Network,
		&i.Currency,
		&i.PaymentUrl,
		&i.CallbackUrl,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCryptomusAddressByUUID = `-- name: GetCryptomusAddressByUUID :one
SELECT id, customer_id, wallet_uuid, uuid, address, network, currency, payment_url, callback_url, status, created_at, updated_at FROM cryptomus_addresses
WHERE uuid = $1 LIMIT 1
`

func (q *Queries) GetCryptomusAddressByUUID(ctx context.Context, uuid string) (CryptomusAddress, error) {
	row := q.db.QueryRowContext(ctx, getCryptomusAddressByUUID, uuid)
	var i CryptomusAddress
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.WalletUuid,
		&i.Uuid,
		&i.Address,
		&i.Network,
		&i.Currency,
		&i.PaymentUrl,
		&i.CallbackUrl,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listCryptomusAddressesByCurrency = `-- name: ListCryptomusAddressesByCurrency :many
SELECT id, customer_id, wallet_uuid, uuid, address, network, currency, payment_url, callback_url, status, created_at, updated_at FROM cryptomus_addresses
WHERE currency = $1
ORDER BY created_at DESC
`

func (q *Queries) ListCryptomusAddressesByCurrency(ctx context.Context, currency string) ([]CryptomusAddress, error) {
	rows, err := q.db.QueryContext(ctx, listCryptomusAddressesByCurrency, currency)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CryptomusAddress{}
	for rows.Next() {
		var i CryptomusAddress
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.WalletUuid,
			&i.Uuid,
			&i.Address,
			&i.Network,
			&i.Currency,
			&i.PaymentUrl,
			&i.CallbackUrl,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCryptomusAddressesByCustomer = `-- name: ListCryptomusAddressesByCustomer :many
SELECT id, customer_id, wallet_uuid, uuid, address, network, currency, payment_url, callback_url, status, created_at, updated_at FROM cryptomus_addresses
WHERE customer_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListCryptomusAddressesByCustomer(ctx context.Context, customerID sql.NullInt64) ([]CryptomusAddress, error) {
	rows, err := q.db.QueryContext(ctx, listCryptomusAddressesByCustomer, customerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CryptomusAddress{}
	for rows.Next() {
		var i CryptomusAddress
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.WalletUuid,
			&i.Uuid,
			&i.Address,
			&i.Network,
			&i.Currency,
			&i.PaymentUrl,
			&i.CallbackUrl,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCryptomusAddressesByNetwork = `-- name: ListCryptomusAddressesByNetwork :many
SELECT id, customer_id, wallet_uuid, uuid, address, network, currency, payment_url, callback_url, status, created_at, updated_at FROM cryptomus_addresses
WHERE network = $1
ORDER BY created_at DESC
`

func (q *Queries) ListCryptomusAddressesByNetwork(ctx context.Context, network string) ([]CryptomusAddress, error) {
	rows, err := q.db.QueryContext(ctx, listCryptomusAddressesByNetwork, network)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CryptomusAddress{}
	for rows.Next() {
		var i CryptomusAddress
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.WalletUuid,
			&i.Uuid,
			&i.Address,
			&i.Network,
			&i.Currency,
			&i.PaymentUrl,
			&i.CallbackUrl,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCryptomusAddressesByNetworkAndCurrency = `-- name: ListCryptomusAddressesByNetworkAndCurrency :many
SELECT id, customer_id, wallet_uuid, uuid, address, network, currency, payment_url, callback_url, status, created_at, updated_at FROM cryptomus_addresses
WHERE network = $1 AND currency = $2
ORDER BY created_at DESC
`

type ListCryptomusAddressesByNetworkAndCurrencyParams struct {
	Network  string `json:"network"`
	Currency string `json:"currency"`
}

func (q *Queries) ListCryptomusAddressesByNetworkAndCurrency(ctx context.Context, arg ListCryptomusAddressesByNetworkAndCurrencyParams) ([]CryptomusAddress, error) {
	rows, err := q.db.QueryContext(ctx, listCryptomusAddressesByNetworkAndCurrency, arg.Network, arg.Currency)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CryptomusAddress{}
	for rows.Next() {
		var i CryptomusAddress
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.WalletUuid,
			&i.Uuid,
			&i.Address,
			&i.Network,
			&i.Currency,
			&i.PaymentUrl,
			&i.CallbackUrl,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCryptomusAddressStatus = `-- name: UpdateCryptomusAddressStatus :one
UPDATE cryptomus_addresses
SET 
    status = $2,
    updated_at = CURRENT_TIMESTAMP
WHERE address = $1
RETURNING id, customer_id, wallet_uuid, uuid, address, network, currency, payment_url, callback_url, status, created_at, updated_at
`

type UpdateCryptomusAddressStatusParams struct {
	Address string `json:"address"`
	Status  string `json:"status"`
}

func (q *Queries) UpdateCryptomusAddressStatus(ctx context.Context, arg UpdateCryptomusAddressStatusParams) (CryptomusAddress, error) {
	row := q.db.QueryRowContext(ctx, updateCryptomusAddressStatus, arg.Address, arg.Status)
	var i CryptomusAddress
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.WalletUuid,
		&i.Uuid,
		&i.Address,
		&i.Network,
		&i.Currency,
		&i.PaymentUrl,
		&i.CallbackUrl,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertCryptomusAddress = `-- name: UpsertCryptomusAddress :one
INSERT INTO cryptomus_addresses (
    customer_id,
    wallet_uuid,
    uuid,
    address,
    network,
    currency,
    payment_url,
    callback_url,
    status,
    updated_at
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
ON CONFLICT (address) DO UPDATE SET
    customer_id = EXCLUDED.customer_id,
    wallet_uuid = EXCLUDED.wallet_uuid,
    uuid = EXCLUDED.uuid,
    address = EXCLUDED.address,
    network = EXCLUDED.network,
    currency = EXCLUDED.currency,
    payment_url = EXCLUDED.payment_url,
    callback_url = EXCLUDED.callback_url,
    status = EXCLUDED.status,
    updated_at = CURRENT_TIMESTAMP
RETURNING id, customer_id, wallet_uuid, uuid, address, network, currency, payment_url, callback_url, status, created_at, updated_at
`

type UpsertCryptomusAddressParams struct {
	CustomerID  sql.NullInt64  `json:"customer_id"`
	WalletUuid  string         `json:"wallet_uuid"`
	Uuid        string         `json:"uuid"`
	Address     string         `json:"address"`
	Network     string         `json:"network"`
	Currency    string         `json:"currency"`
	PaymentUrl  sql.NullString `json:"payment_url"`
	CallbackUrl sql.NullString `json:"callback_url"`
	Status      string         `json:"status"`
	UpdatedAt   sql.NullTime   `json:"updated_at"`
}

func (q *Queries) UpsertCryptomusAddress(ctx context.Context, arg UpsertCryptomusAddressParams) (CryptomusAddress, error) {
	row := q.db.QueryRowContext(ctx, upsertCryptomusAddress,
		arg.CustomerID,
		arg.WalletUuid,
		arg.Uuid,
		arg.Address,
		arg.Network,
		arg.Currency,
		arg.PaymentUrl,
		arg.CallbackUrl,
		arg.Status,
		arg.UpdatedAt,
	)
	var i CryptomusAddress
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.WalletUuid,
		&i.Uuid,
		&i.Address,
		&i.Network,
		&i.Currency,
		&i.PaymentUrl,
		&i.CallbackUrl,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
